## 2020-4-27:项目初始化

### 1、添加antd

#### 安装:

`yarn add antd`

#### 使用:

引入:想在哪个组件用，就在哪个组件引入

`import {Button} from 'antd'`

引入样式：

`import 'antd/dist/antd.css'`

### 2、优化antd,按需引入样式

#### 配置按需引入:

(参考官网的在 create-react-app 中使用文档)
1.切到文档的【高级配置】
2.yarn add react-app-rewired customize-cra
3.修改package.json（看文档）
  "scripts": {
      "start": "react-app-rewired start",
      "build": "react-app-rewired build",
      "test": "react-app-rewired test",
      "eject": "react-scripts eject"
    },
4.建立：config-overrides.js(具体内容，参考官网)
5.yarn add babel-plugin-import
6.修改config-overrides.js文件(具体内容，参考官网)
7.删除掉App.js中的antd.css的引入

#### 配置自定义主题样式:

1.切到文档的自定义主题
2.yarn add less less-loader@5(下载5版本的，并按照官网提示操作。6版本可能会报错)
3.修改config-overrides.js，最终版：
```
const { override, fixBabelImports,addLessLoader } = require('customize-cra');
module.exports = override(
    fixBabelImports('import', {
      libraryName: 'antd',
      libraryDirectory: 'es',
      style: true
    }),
addLessLoader({
    javascriptEnabled: true,
    modifyVars: { '@primary-color': 'red' },
    }),
);
```
  


## 2020-4-28: 路由和ajax

### 1、引入react-router-dom,搭建路由

#### 1、安装:

`yarn add react-router-dom`

#### 2、使用:

引入:
`import {link,Switch,Route,Redirect} from 'react-router-dom'`

#### 注意:
`注意:link外面必须包裹Router,但是直接写会报错`
`现在Router已经分为了BrowserRouter和HashRouter`
`所以使用BrowserRouter或HashRouter`
`为了方便，通常在主index.jsx中,包裹在<App/>外`


### 2、引入antd的form组件

#### 使用:

**例:**
```
import { Form, Input, Button } from 'antd';
// 表单验证成功后才触发onFinish
onFinish = async values => {
  };

  // verify在输入框有内容输入时触发，校验密码
  verify = (_, values) => {
    if () {
      //输出成功的promise
      return Promise.resolve()
    } else {
      //输出失败的promise
      return Promise.reject()
    }
  }

<Form
  name="normal_login"
  className="login-form"
  initialValues={{
    remember: true,
  }}
  onFinish={this.onFinish}//表单验证成功后才触发onFinish
>
  <Item
    name="username"
    // 校验规则，设置字段的校验逻辑
    rules={[
      {required: true,message: '请输入用户名!',},
      {whitespace: true,message: '用户名不能为空'},
      {max: 12,message: '用户名长度最大为12位字符！'},
      {min: 4,message: '用户名长度最小为4位字符！'},
      {pattern: /^\w+$/,message: '用户名必须是字母,数字或下划线组成！'},
    ]}
    // 自定义校验，接收 Promise 作为返回值 
    <!-- rules={[
      {
        validator: this.verify
      },
    ]} -->
  >
  <Item>
    <Button type="primary" htmlType="submit" className="login-form-button">
      登录
    </Button>
  </Item>
</Form>
```

#### 注意:

1、Form标签中的onFinish属性，在表单验证成功后才触发

`onFinish={this.onFinish}`

2、校验器的返回值是Promise，第一个参数我们不用。

`verify = (_, values) =>{if () {//输出成功的promisereturn Promise.resolve()}` 
`else { //输出失败的promisereturn Promise.reject()} }`

`rules={[{ validator: this.verify}]}`

### 3、 配置代理解决跨域问题

在package.json中配置代理
`"proxy": "http://localhost:4000"`

### 4、 二次封装axios

#### 1.配置请求的基础路径

`axios.defaults.baseURL = '基础路径'`

#### 2.配置超时时间

`axios.defaults.timeout = 超时时间 `

#### 3.配置请求拦截器

 **统一处理post请求json编码问题（转为urlencoded）**

```
axios.interceptors.request.use((config)=>{
	const {method,data} = config
	//统一处理post请求json编码问题（转为urlencoded）
	if(method.toLowerCase() === 'post' && data instanceof Object){
		config.data = qs.stringify(data)
	}
	//必须返回配置对象
	return config
})
```

#### 4.配置响应拦截器

统一返回真正的数据data，而不是response对象
统一处理错误

```
axios.interceptors.response.use(
	//成功的回调：返回的http状态码是2开头
	response => {
		return response.data
	},
	//失败的回调：1.返回的http状态码不是2开头；2.达到了超时时间；3.网络不通
	err => {
		let errmsg = '未知错误，请联系管理员'
		const {message} = err
		if(message.indexOf('401') !== -1) errmsg = '未登录或身份过期，请重新登录！'
		else if(message.indexOf('Network Error') !== -1) errmsg = '网络不通，请检查网络连接！'
		else if(message.indexOf('timeout') !== -1) errmsg = '网络不稳定，连接超时！'
		msg.error(errmsg,1)
		return new Promise(()=>{})
	}
)
```

#### 注意:

`二次封装的axios中必须向外暴露axios :export default axios`

#### 抽离组件中的ajax请求,统一添加到api/index.jx中。方便后期管理

## 2020-4-29: redux

